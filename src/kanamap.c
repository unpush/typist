/* ------------------------------------------------------
	kanamap.c	for typist
---------------------------------------------------------
	Original: D. Jason Penney (penneyj@slc.com)
	Tuned for Japanese Users: Takeshi Ogihara
	Ver.1.0   1992-07-14
	Ver.2.0   1997-05-17	Kana Exercise
	by Takeshi Ogihara  (ogihara@seg.kobe-u.ac.jp)
	Ver.3.0   2007-09-06	by Takeshi Ogihara
------------------------------------------------------ */

#include <stdio.h>
#include <stdlib.h>

#include "kana.h"
#include "typist.h"
#include "http.h"

#if defined(KANA_LESSON)
kanachar kanamap[256];
#endif

kanachar kchars[] = {
    0,
#ifdef JPN
#if (KANA_CODE == UTF_8)
    0xe38080, 0xe38081, 0xe38082, 0xe383bc, 0xe3808c, 0xe3808d, 0xefbc88, 0xefbc89, 0xefbc9f, 0xefbc81, 
    0xEFBC90, 0xEFBC91, 0xEFBC92, 0xEFBC93, 0xEFBC94,
    0xEFBC95, 0xEFBC96, 0xEFBC97, 0xEFBC98, 0xEFBC99,
    0xe38181, 0xe38182, 0xe38183, 0xe38184, 0xe38185, 0xe38186, 0xe38187, 0xe38188, 0xe38189, 0xe3818a, 
    0xe3818b, 0xe3818c, 0xe3818d, 0xe3818e, 0xe3818f, 0xe38190, 0xe38191, 0xe38192, 0xe38193, 0xe38194, 
    0xe38195, 0xe38196, 0xe38197, 0xe38198, 0xe38199, 0xe3819a, 0xe3819b, 0xe3819c, 0xe3819d, 0xe3819e, 
    0xe3819f, 0xe381a0, 0xe381a1, 0xe381a2, 0xe381a3, 0xe381a4, 0xe381a5, 0xe381a6, 0xe381a7, 0xe381a8, 
    0xe381a9, 0xe381aa, 0xe381ab, 0xe381ac, 0xe381ad, 0xe381ae, 0xe381af, 0xe381b0, 0xe381b1, 0xe381b2, 
    0xe381b3, 0xe381b4, 0xe381b5, 0xe381b6, 0xe381b7, 0xe381b8, 0xe381b9, 0xe381ba, 0xe381bb, 0xe381bc, 
    0xe381bd, 0xe381be, 0xe381bf, 0xe38280, 0xe38281, 0xe38282, 0xe38283, 0xe38284, 0xe38285, 0xe38286, 
    0xe38287, 0xe38288, 0xe38289, 0xe3828a, 0xe3828b, 0xe3828c, 0xe3828d, 0xe3828e, 0xe3828f, 0xe38290, 
    0xe38291, 0xe38292, 0xe38293, 0xe383b4, 0xe383b5, 0xe383b6, 0xe382a1, 0xe382a3, 0xe382a5, 0xe382a7, 
    0xe382a9, 0xe383a3, 0xe383a5, 0xe383a7

#elif (KANA_CODE == ShiftJIS)
    0x8140, 0x8141, 0x8142, 0x815b, 0x8175, 0x8176, 0x8169, 0x816a, 0x8148, 0x8149, 
    0x824F, 0x8250, 0x8251, 0x8252, 0x8253,
    0x8254, 0x8255, 0x8256, 0x8257, 0x8258,
    0x829f, 0x82a0, 0x82a1, 0x82a2, 0x82a3, 0x82a4, 0x82a5, 0x82a6, 0x82a7, 0x82a8, 
    0x82a9, 0x82aa, 0x82ab, 0x82ac, 0x82ad, 0x82ae, 0x82af, 0x82b0, 0x82b1, 0x82b2, 
    0x82b3, 0x82b4, 0x82b5, 0x82b6, 0x82b7, 0x82b8, 0x82b9, 0x82ba, 0x82bb, 0x82bc, 
    0x82bd, 0x82be, 0x82bf, 0x82c0, 0x82c1, 0x82c2, 0x82c3, 0x82c4, 0x82c5, 0x82c6, 
    0x82c7, 0x82c8, 0x82c9, 0x82ca, 0x82cb, 0x82cc, 0x82cd, 0x82ce, 0x82cf, 0x82d0, 
    0x82d1, 0x82d2, 0x82d3, 0x82d4, 0x82d5, 0x82d6, 0x82d7, 0x82d8, 0x82d9, 0x82da, 
    0x82db, 0x82dc, 0x82dd, 0x82de, 0x82df, 0x82e0, 0x82e1, 0x82e2, 0x82e3, 0x82e4, 
    0x82e5, 0x82e6, 0x82e7, 0x82e8, 0x82e9, 0x82ea, 0x82eb, 0x82ec, 0x82ed, 0x82ee, 
    0x82ef, 0x82f0, 0x82f1, 0x8394, 0x8395, 0x8396, 0x8340, 0x8342, 0x8344, 0x8346, 
    0x8348, 0x8383, 0x8385, 0x8387

#else /* KANA_CODE == EUC_JP */
	0xa1a1, 0xa1a2, 0xa1a3, 0xa1bc, 0xa1d6, 0xa1d7, 0xa1ca, 0xa1cb, 0xa1a9, 0xa1aa,
    0xA3B0, 0xA3B1, 0xA3B2, 0xA3B3, 0xA3B4,
    0xA3B5, 0xA3B6, 0xA3B7, 0xA3B8, 0xA3B9,
    0xa4a1, 0xa4a2, 0xa4a3, 0xa4a4, 0xa4a5, 0xa4a6, 0xa4a7, 0xa4a8, 0xa4a9, 0xa4aa, 
    0xa4ab, 0xa4ac, 0xa4ad, 0xa4ae, 0xa4af, 0xa4b0, 0xa4b1, 0xa4b2, 0xa4b3, 0xa4b4, 
    0xa4b5, 0xa4b6, 0xa4b7, 0xa4b8, 0xa4b9, 0xa4ba, 0xa4bb, 0xa4bc, 0xa4bd, 0xa4be, 
    0xa4bf, 0xa4c0, 0xa4c1, 0xa4c2, 0xa4c3, 0xa4c4, 0xa4c5, 0xa4c6, 0xa4c7, 0xa4c8, 
    0xa4c9, 0xa4ca, 0xa4cb, 0xa4cc, 0xa4cd, 0xa4ce, 0xa4cf, 0xa4d0, 0xa4d1, 0xa4d2, 
    0xa4d3, 0xa4d4, 0xa4d5, 0xa4d6, 0xa4d7, 0xa4d8, 0xa4d9, 0xa4da, 0xa4db, 0xa4dc, 
    0xa4dd, 0xa4de, 0xa4df, 0xa4e0, 0xa4e1, 0xa4e2, 0xa4e3, 0xa4e4, 0xa4e5, 0xa4e6, 
    0xa4e7, 0xa4e8, 0xa4e9, 0xa4ea, 0xa4eb, 0xa4ec, 0xa4ed, 0xa4ee, 0xa4ef, 0xa4f0, 
    0xa4f1, 0xa4f2, 0xa4f3, 0xa5f4, 0xa5f5, 0xa5f6, 0xa5a1, 0xa5a3, 0xa5a5, 0xa5a7, 
    0xa5a9, 0xa5e3, 0xa5e5, 0xa5e7
#endif
#endif /* JPN */
};


#if defined(KANA_LESSON)

#define  KMAXLEN	128

BoolType init_kanamap(const char *libdir, const char *key_type)
{
	FILEsIO	*fp;
	unsigned char	buf[KMAXLEN];
	int	i, cc;
	kanachar k0, kv;
	static int	alreadyused = 0;
	StrType mapfile;

	if (alreadyused)
		return TRUE;
	for (i = 0; i < 256; i++)
		kanamap[i] = kchars[s_sp];
	if (isHttp) {
		sprintf(mapfile, "%s/%s.map", libdir, key_type);
		fp = open_url(mapfile);
	}else {
		sprintf(mapfile, "%s%c%s.map", libdir, DELIM, key_type);
		fp = makeFilesio( fopen(mapfile, "r") );
	}
	if (fp == NULL)
		return FALSE;
	while (iogets((char *)buf, KMAXLEN, fp) != NULL) {
		if ((cc = buf[0]) <= ' ') continue;
		for (i = 1; buf[i] == ' ' || buf[i] == '\t'; i++)
			;
		k0 = buf[i++] & 0xff;
		kv = (k0 << 8) | (buf[i++] & 0xff);
#if (KANA_CODE == UTF_8)
		if (k0 >= 0xe0) {
			kv = (kv << 8) | (buf[i++] & 0xff);
			if (k0 > 0xef)
				kv = (kv << 8) | (buf[i++] & 0xff);
		}
#endif
		kanamap[cc] = kv;
	}
	alreadyused = 1;
	ioclose(fp);
	return TRUE;
}

#endif /* KANA_LESSON */
